package dev.schlaubi.mikbot.gradle

import dev.schlaubi.mikbot.gradle.extension.mikbotPluginExtension
import dev.schlaubi.mikbot.gradle.extension.pluginId
import org.gradle.api.Project
import org.gradle.api.file.DuplicatesStrategy
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.TaskProvider
import org.gradle.api.tasks.bundling.Jar
import org.gradle.api.tasks.bundling.Zip
import java.nio.file.Path
import kotlin.io.path.name

// There might be a better way of doing this, but for now I can't be bothered figuring it out
private val Project.pluginMainFile: Path
    get() = buildDir
        .resolve("generated")
        .resolve("ksp")
        .resolve("main")
        .resolve("resources")
        .resolve("META-INF")
        .resolve("plugin.properties")
        .toPath()

internal data class AssemblyTask(val assembleTask: TaskProvider<Zip>, val installBotTask: InstallBotTask)

context(Project)
internal fun TaskContainer.createAssembleTasks(): AssemblyTask {
    val patchPropertiesTask = createPatchPropertiesTask()

    val jar = tasks.findByName("jar") as Jar? ?: pluginNotAppliedError("Kotlin")
    jar.dependsOn(patchPropertiesTask)
    val assembleTask = createAssemblePluginTask(jar)
    val installBotTask = tasks.create("installBot", InstallBotTask::class.java)
    createAssembleBotTask(assembleTask, installBotTask)
    return AssemblyTask(assembleTask, installBotTask)
}

context(Project)
private fun TaskContainer.createAssembleBotTask(assemblePlugin: TaskProvider<Zip>, installBotTask: InstallBotTask) {
    val assembleBot = register<AssembleBotTask>("assembleBot") {
        dependsOn(assemblePlugin, installBotTask)
        this.assemblePlugin.set(assemblePlugin)
        this.installBotTask.set(installBotTask)
    }
    afterEvaluate {
        assembleBot.get().config()
    }

    register<Copy>("installBotArchive") {
        dependsOn(assembleBot)

        from(zipTree(assembleBot.get().archiveFile))
        into(buildDir.resolve("installBot"))
    }
}

context(Project)
private fun TaskContainer.createPatchPropertiesTask() =
    register<PatchPropertiesTask>("patchPluginProperties") {
        group = "mikbot-plugin"
        dependsOn("kspKotlin")
        propertiesDirectory.set(
            project
                .mikbotPluginExtension
                .pluginMainFileLocation
                .getOrElse(project.pluginMainFile)
                .parent
        )

        doFirst {
            if (!project.tasks.getByName("kspKotlin").didWork) {
                this.didWork = false
            }
        }
    }

// Taken from: https://github.com/twatzl/pf4j-kotlin-demo/blob/master/plugins/build.gradle.kts#L20-L35
// Funfact: because the kotlin dsl is missing we only have groovy api
// this means all the lambdas are normal lambdas and not lambdas with receivers
// therefore not calling it, would always use the main spec
// which took me 4 hrs to figure out
context(Project)
private fun TaskContainer.createAssemblePluginTask(jarTask: Jar) =
        register<Zip>("assemblePlugin") {
            group = "build"
            dependsOn(jarTask)

            duplicatesStrategy = DuplicatesStrategy.EXCLUDE

            destinationDirectory.set(buildDir.resolve("plugin"))
            archiveBaseName.set("plugin-${project.pluginId}")
            archiveExtension.set("zip")

            // first taking the classes generated by the jar task
            into("classes") {
                it.with(jarTask)
            }

            // and then we also need to include any libraries that are needed by the plugin
            dependsOn(configurations.getByName("runtimeClasspath"))
            into("lib") {
                it.from({
                    val mainConfiguration = if (!project.mikbotPluginExtension
                            .ignoreDependencies
                            .getOrElse(false)
                    ) {
                        transientDependencies
                            .lines()
                            .filterNot { file -> file.startsWith("#") || file.isBlank() }
                    } else {
                        emptyList()
                    }

                    // filter out dupe dependencies
                    configurations.getByName("runtimeClasspath").resolvedConfiguration.resolvedArtifacts.asSequence()
                        .filter { dep ->
                            (dep.moduleVersion.id.group + ":" + dep.moduleVersion.id.name) !in mainConfiguration
                        }.mapNotNull { dep ->
                            dep.file
                        }.toList()
                })
            }

            into("") { // not specifying "" brakes Gradle btw
                val file = project.mikbotPluginExtension.pluginMainFileLocation
                    .getOrElse(pluginMainFile)
                it.from(file.parent)
                it.include(file.name)
            }
        }

