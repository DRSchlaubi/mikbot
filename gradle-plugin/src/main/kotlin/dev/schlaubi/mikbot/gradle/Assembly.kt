package dev.schlaubi.mikbot.gradle

import dev.schlaubi.mikbot.gradle.extension.mikbotPluginExtension
import dev.schlaubi.mikbot.gradle.extension.pluginId
import org.gradle.api.Project
import org.gradle.api.file.DuplicatesStrategy
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.TaskProvider
import org.gradle.api.tasks.bundling.Jar
import org.gradle.api.tasks.bundling.Zip
import org.gradle.kotlin.dsl.*
import java.net.URI
import java.nio.file.Path
import kotlin.io.path.name

// There might be a better way of doing this, but for now I can't be bothered figuring it out
private val Project.pluginMainFile: Path
    get() = buildDir
        .resolve("generated")
        .resolve("ksp")
        .resolve("main")
        .resolve("resources")
        .resolve("META-INF")
        .resolve("plugin.properties")
        .toPath()

internal data class AssemblyTask(val assembleTask: TaskProvider<Zip>, val installBotTask: InstallBotTask)

context(Project)
internal fun TaskContainer.createAssembleTasks(): AssemblyTask {
    val patchPropertiesTask = createPatchPropertiesTask()

    val jar = tasks.findByName("jar") as Jar? ?: pluginNotAppliedError("Kotlin")
    jar.dependsOn(patchPropertiesTask)
    val assembleTask = createAssemblePluginTask(jar)
    val installBotTask = tasks.create("installBot", InstallBotTask::class.java)
    createAssembleBotTask(assembleTask, installBotTask)
    return AssemblyTask(assembleTask, installBotTask)
}

context(Project)
private fun TaskContainer.createAssembleBotTask(assemblePlugin: TaskProvider<Zip>, installBotTask: InstallBotTask) {
    repositories {
        ivy {
            url = URI("https://storage.googleapis.com/mikbot-binaries")
            patternLayout {
                artifact("[revision]/[artifact]-[revision].[ext]")
            }
            metadataSources {
                artifact()
            }
        }
    }

    val assembleBot = register<AssembleBotTask>("assembleBot") {
        dependsOn(assemblePlugin, installBotTask)
        this.assemblePlugin = assemblePlugin
        this.installBotTask = installBotTask
    }
    afterEvaluate {
        assembleBot.get().config()
    }

    register<Copy>("installBotArchive") {
        dependsOn(assembleBot)

        from(zipTree(assembleBot.get().archiveFile))
        into(buildDir.resolve("installBot"))
    }
}

context(Project)
private fun TaskContainer.createPatchPropertiesTask() =
    register<PatchPropertiesTask>("patchPluginProperties") {
        group = "mikbot-plugin"
        dependsOn("kspKotlin")
        propertiesDirectory =
            project
                .mikbotPluginExtension
                .pluginMainFileLocation
                .getOrElse(project.pluginMainFile)
                .parent


        doFirst {
            if (!project.tasks.getByName("kspKotlin").didWork) {
                this.didWork = false
            }
        }
    }

// Taken from: https://github.com/twatzl/pf4j-kotlin-demo/blob/master/plugins/build.gradle.kts#L20-L35
// Funfact: because the kotlin dsl is missing we only have groovy api
// this means all the lambdas are normal lambdas and not lambdas with receivers
// therefore not calling it, would always use the main spec
// which took me 4 hrs to figure out
context(Project)
private fun TaskContainer.createAssemblePluginTask(jarTask: Jar) =
    register<Zip>("assemblePlugin") {
        group = "build"
        dependsOn(jarTask)

        duplicatesStrategy = DuplicatesStrategy.EXCLUDE

        destinationDirectory = buildDir.resolve("plugin")
        archiveBaseName = "plugin-${project.pluginId}"
        archiveExtension = "zip"

        // first taking the classes generated by the jar task
        into("classes") {
            with(jarTask)
        }

        // and then we also need to include any libraries that are needed by the plugin
        dependsOn(configurations.getByName("runtimeClasspath"))
        into("lib") {
            from({
                val mainConfiguration = if (!project.mikbotPluginExtension
                        .ignoreDependencies
                        .getOrElse(false)
                ) {
                    transientDependencies
                        .lines()
                        .filterNot { file -> file.startsWith("#") || file.isBlank() }
                } else {
                    emptyList()
                }

                // filter out dupe dependencies
                configurations.getByName("runtimeClasspath").resolvedConfiguration.resolvedArtifacts.asSequence()
                    .filter { dep ->
                        val idWithoutPlatform = dep.moduleVersion.id.name.substringBefore("-jvm")
                        (dep.moduleVersion.id.group + ":" + idWithoutPlatform) !in mainConfiguration
                    }.mapNotNull { dep ->
                        dep.file
                    }.toList()
            })
        }

        into("") { // not specifying "" brakes Gradle btw
            val file = project.mikbotPluginExtension.pluginMainFileLocation
                .getOrElse(pluginMainFile)
            from(file.parent)
            include(file.name)
        }
    }

