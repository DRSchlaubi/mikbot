import java.nio.file.Files

plugins {
    id("com.google.devtools.ksp") // used for plugin-processor
    kotlin("jvm")
    kotlin("kapt") // used for pf4j processor
}

val pluginExtensionName = "mikbotPlugin"

extensions.create<PluginExtension>(pluginExtensionName)

val pluginMainPath = buildDir.toPath().resolve("plugin-reports").resolve(name)
val pluginMainFile = pluginMainPath.resolve("plugin-main-class.txt")

val plugin by configurations.creating
val optionalPlugin by configurations.creating

configurations {
    compileOnly {
        extendsFrom(plugin)
        extendsFrom(optionalPlugin)
    }
}

dependencies {
    compileOnly(kotlin("stdlib-jdk8")) // this one is included in the bot itself
    compileOnly(project(":api"))
    kapt("org.pf4j", "pf4j", "3.6.0")
    ksp(project(":plugin-processor"))
}

ksp {
    arg("output-dir", pluginMainPath.toAbsolutePath().toString())
}

tasks {
    jar {
        dependsOn("kspKotlin")
    }

    // Taken from: https://github.com/twatzl/pf4j-kotlin-demo/blob/master/plugins/build.gradle.kts#L20-L35
    tasks.register<Jar>("assemblePlugin") {
        dependsOn(jar)

        destinationDirectory.set(buildDir.resolve("plugin"))
        archiveBaseName.set("plugin-${project.name}")

        // first taking the classes generated by the jar task
        into("classes") {
            with(jar.get())
        }

        // and then we also need to include any libraries that are needed by the plugin
        dependsOn(configurations.runtimeClasspath)
        into("lib") {
            from({
                val mainConfiguration = project(":").configurations["runtimeClasspath"].files.map { it.removeVersion() }

                // filter out dupe dependencies
                configurations.runtimeClasspath.get().files.filter {
                    it.removeVersion() !in mainConfiguration
                }
            })
        }
        archiveExtension.set("zip")
    }

    afterEvaluate {
        jar {
            doLast {
                val mainClass = Files.readString(pluginMainFile)
                val extension = project.extensions.getByName<PluginExtension>(pluginExtensionName)
                manifest {
                    attributes["Plugin-Class"] = mainClass
                    attributes["Plugin-Id"] = project.name
                    attributes["Plugin-Version"] = (project.version as String)
                    extension.requires.orNull?.let { requires ->
                        attributes["Plugin-Requires"] = requires
                    }
                    buildDependenciesString().takeIf { it.isNotBlank() }?.let { dependencies ->
                        attributes["Plugin-Dependencies"] = dependencies
                    }

                    attributes["Plugin-Description"] = extension.description.getOrElse("<no description>")
                    attributes["Plugin-Provider"] = extension.provider.getOrElse("MikBot Contributors")
                    attributes["Plugin-License"] = extension.license.getOrElse("Apache 2.0")
                }
            }
        }
    }
}

fun buildDependenciesString(): String {
    val required = plugin.allDependencies.map { it.toDependencyString() }
    val optional = optionalPlugin.allDependencies.map { it.toDependencyString(true) }

    return (required + optional).joinToString(", ")
}

fun Dependency.toDependencyString(optional: Boolean = false): String {
    val name = if (this is ProjectDependency) {
        dependencyProject.name
    } else {
        name
    }

    return "$name${if (optional) "?" else ""}@$version"
}

abstract class PluginExtension {
    abstract val mainClass: Property<String>
    abstract val requires: Property<String>
    abstract val dependencies: ListProperty<String>
    abstract val description: Property<String>
    abstract val provider: Property<String>
    abstract val license: Property<String>
}

fun File.removeVersion() = name.takeWhile { !it.isDigit() }
