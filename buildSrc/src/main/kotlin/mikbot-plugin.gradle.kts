import dev.schlaubi.mikbot.plugins.gradle.publishing.MakeRepositoryIndexTask
import dev.schlaubi.mikbot.plugins.gradle.publishing.PluginExtension
import dev.schlaubi.mikbot.plugins.gradle.publishing.pluginExtensionName
import java.nio.file.Files

plugins {
    id("com.google.devtools.ksp") // used for plugin-processor
    kotlin("jvm")
    kotlin("kapt") // used for pf4j processor
}

extensions.create<PluginExtension>(pluginExtensionName)

val pluginMainPath = buildDir.toPath().resolve("plugin-reports").resolve(name)
val pluginMainFile = pluginMainPath.resolve("plugin-main-class.txt")

val plugin by configurations.creating
val optionalPlugin by configurations.creating

configurations {
    compileOnly {
        extendsFrom(plugin)
        extendsFrom(optionalPlugin)
    }
}

dependencies {
    compileOnly(kotlin("stdlib-jdk8")) // this one is included in the bot itself
    compileOnly(project(":api"))
    kapt("org.pf4j", "pf4j", "3.6.0")
    ksp(project(":plugin-processor"))
}

ksp {
    arg("output-dir", pluginMainPath.toAbsolutePath().toString())
}

tasks {
    // KSP caches forgets about annotations all the tme
    val deleteKspCache = task<Delete>("deleteKspCache") {
        delete(buildDir.resolve("kspCaches"))
    }

    jar {
        dependsOn(deleteKspCache, "kspKotlin")
    }

    // Taken from: https://github.com/twatzl/pf4j-kotlin-demo/blob/master/plugins/build.gradle.kts#L20-L35
    val archive = register<Jar>("assemblePlugin") {
        dependsOn(jar)

        destinationDirectory.set(buildDir.resolve("plugin"))
        archiveBaseName.set("plugin-${project.name}")

        // first taking the classes generated by the jar task
        into("classes") {
            with(jar.get())
        }

        // and then we also need to include any libraries that are needed by the plugin
        dependsOn(configurations.runtimeClasspath)
        into("lib") {
            from({
                val mainConfiguration = project(":").configurations["runtimeClasspath"].files.map { it.removeVersion() }

                // filter out dupe dependencies
                configurations.runtimeClasspath.get().files.filter {
                    it.removeVersion() !in mainConfiguration
                }
            })
        }
        archiveExtension.set("zip")
    }

    afterEvaluate {
        jar {
            doLast {
                val mainClass = Files.readString(pluginMainFile)
                val extension = project.extensions.getByName<PluginExtension>(pluginExtensionName)
                manifest {
                    attributes["Plugin-Class"] = mainClass
                    attributes["Plugin-Id"] = project.name
                    attributes["Plugin-Version"] = (project.version as String)
                    extension.requires.orNull?.let { requires ->
                        attributes["Plugin-Requires"] = requires
                    }
                    buildDependenciesString().takeIf { it.isNotBlank() }?.let { dependencies ->
                        attributes["Plugin-Dependencies"] = dependencies
                    }

                    attributes["Plugin-Description"] = extension.description.getOrElse("<no description>")
                    attributes["Plugin-Provider"] = extension.provider.getOrElse("MikBot Contributors")
                    attributes["Plugin-License"] = extension.license.getOrElse("Apache 2.0")
                }
            }
        }
    }

    val repository = rootProject.file("ci-repo").toPath()

    val buildRepository = task<MakeRepositoryIndexTask>("buildRepository") {
        targetDirectory.set(repository)
        repositoryUrl.set("https://plugin-repository.mikbot.schlaubi.net")
    }

    afterEvaluate {
        task<Copy>("copyFilesIntoRepo") {
            dependsOn(buildRepository)
            from(archive)
            include("*.zip")
            // providing version manually, as of weird evaluation errors
            into(repository.resolve("${project.name}/$version"))
        }
    }
}

fun buildDependenciesString(): String {
    val required = plugin.allDependencies.map { it.toDependencyString() }
    val optional = optionalPlugin.allDependencies.map { it.toDependencyString(true) }

    return (required + optional).joinToString(", ")
}

fun Dependency.toDependencyString(optional: Boolean = false): String {
    val name = if (this is ProjectDependency) {
        dependencyProject.name
    } else {
        name
    }

    return "$name${if (optional) "?" else ""}@$version"
}

fun File.removeVersion() = name.takeWhile { !it.isDigit() }
